{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1hexo new &quot;My New Post&quot; More info: Writing Run server1hexo server More info: Server Generate static files1hexo generate More info: Generating Deploy to remote sites1hexo deploy More info: Deployment","link":"/2024/05/14/hello-world/"},{"title":"如何处理使用openiddict出现&#96;IDX&#96;相关的问题","text":"结论：通常出现IDX相关问题是因为无法调用.well-known/openid-configuration接口造成的。因此，我们需要对认证服务器和推荐服务器进行以下配置。下面的代码基于AbpVNext和openiddict。 openiddict认证服务器进行以下配置： 1234567{ &quot;AuthServer&quot;: { &quot;Authority&quot;: &quot;http://localhost:44330&quot;, &quot;MetadataAddress&quot;: &quot;http://localhost:44330/.well-known/openid-configuration&quot;, &quot;RequireHttpsMetadata&quot;: &quot;false&quot; }} 在开发环境中，openiddict 要求进行HTTPS验证和证书。因此，在非HTTPS环境中，需要生成开发证书并禁用HTTPS验证。可以通过builder.AddDevelopmentEncryptionCertificate().AddDevelopmentSigningCertificate();添加开发证书。 123456789101112131415161718192021222324252627282930313233343536373839404142public override void PreConfigureServices(ServiceConfigurationContext context){ var configuration = context.Services.GetConfiguration(); var requireHttpsMetadata = configuration.GetValue&lt;bool&gt;(&quot;AuthServer:RequireHttpsMetadata&quot;); PreConfigure&lt;OpenIddictServerBuilder&gt;(builder =&gt; { builder.SetIssuer(new Uri(configuration[&quot;AuthServer:Authority&quot;]!)); if (requireHttpsMetadata) { builder.AddDevelopmentEncryptionCertificate().AddDevelopmentSigningCertificate(); return; } using (var algorithm = RSA.Create(2048)) { var subject = new X500DistinguishedName(&quot;CN=Fabrikam Encryption Certificate&quot;); var request = new CertificateRequest(subject, algorithm, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1); request.CertificateExtensions.Add(new X509KeyUsageExtension(X509KeyUsageFlags.DigitalSignature, true)); var certificate = request.CreateSelfSigned(DateTimeOffset.UtcNow, DateTimeOffset.UtcNow.AddYears(2)); builder.AddSigningCertificate(certificate); } using (var algorithm = RSA.Create(2048)) { var subject = new X500DistinguishedName(&quot;CN=Fabrikam Signing Certificate&quot;); var request = new CertificateRequest(subject, algorithm, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1); request.CertificateExtensions.Add(new X509KeyUsageExtension(X509KeyUsageFlags.KeyEncipherment, true)); var certificate = request.CreateSelfSigned(DateTimeOffset.UtcNow, DateTimeOffset.UtcNow.AddYears(2)); builder.AddEncryptionCertificate(certificate); } }); PreConfigure&lt;OpenIddictBuilder&gt;(builder =&gt; { builder.AddValidation(options =&gt; { options.UseLocalServer(); }); // disable ssl validate if RequireHttpsMetadata is false. if (!requireHttpsMetadata) { builder.AddServer(serverBuilder =&gt; { serverBuilder.UseAspNetCore().DisableTransportSecurityRequirement(); }); } });} 资源服务器资源服务器通过调用认证服务器的 .well-known/openid-configuration 接口来验证 token。调用认证服务器的接口有两种方式，默认使用 Authority 和配置 MetadataAddress： 默认情况下，Authority 会自动请求 .well-known/openid-configuration 获取验证信息。因此，确保资源服务器可以访问认证服务器。否则，就会产生 IDX 相关问题。 如果无法通过 Authority 访问认证服务器，则可以配置 MetadataAddress 来访问，它是一个完整的地址。这种方式通常用于无法使用 HTTPS 访问认证服务器的开发环境下的额外配置。 123456789context.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =&gt; { options.Authority = configuration[&quot;AuthServer:Authority&quot;]; var metadataAddress = configuration[&quot;AuthServer:MetadataAddress&quot;]; if (!metadataAddress.IsNullOrEmpty()) options.MetadataAddress = metadataAddress; options.RequireHttpsMetadata = Convert.ToBoolean(configuration[&quot;AuthServer:RequireHttpsMetadata&quot;]); options.Audience = audience; }); 这样做的目的是，我使用 mkcert 创建了本地证书，但是在运行在 Kubernetes 中的 pod 上，无法使用本地证书。因此，需要额外配置 MetadataAddress 以服务名的方式进行访问，并且不验证 HTTPS。","link":"/2024/05/15/oauth-idx-error/"}],"tags":[{"name":"demo","slug":"demo","link":"/tags/demo/"},{"name":"oAuth","slug":"oAuth","link":"/tags/oAuth/"},{"name":"AbpVNext","slug":"AbpVNext","link":"/tags/AbpVNext/"},{"name":"openiddict","slug":"openiddict","link":"/tags/openiddict/"}],"categories":[{"name":"hexo-demo","slug":"hexo-demo","link":"/categories/hexo-demo/"},{"name":"dev blog","slug":"dev-blog","link":"/categories/dev-blog/"}],"pages":[{"title":"About Me","text":"Full stack developer, looking for remote job and create my product OneSpace","link":"/about/index.html"},{"title":"archives","text":"","link":"/archives/index.html"},{"title":"Tags","text":"No tags.","link":"/tags/index.html"},{"title":"Categories","text":"OneSpace","link":"/categories/index.html"}]}